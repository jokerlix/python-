
列表
列表长度可变 包含内容可以修改
In [1]: a_list = [1,2,3,None]                          

In [2]: tup = ('foo','bar','baz')                      

In [3]: b_list = list(tup)                             

In [4]: b_list                                         
Out[4]: ['foo', 'bar', 'baz']

In [5]: b_list[1] = 'mother_fuker'                     

In [6]: b_list                                         
Out[6]: ['foo', 'mother_fuker', 'baz']

In [7]:  

list 函数在数据处理中常用于 迭代器 或者生成器转化为列表
In [7]: gen = range(10)                                

In [8]: gen                                            
Out[8]: range(0, 10)

In [9]: list(gen)                                      
Out[9]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [10]:                                               

append() 方法在结尾添加内容
insert() 方法在指定位置添加内容

In [11]: b_list.append('dkjfj')                        

In [12]: b_list                                        
Out[12]: ['foo', 'mother_fuker', 'baz', 'dkjfj']

In [13]: b_list.insert(1,'red')                        

In [14]: b_list                                        
Out[14]: ['foo', 'red', 'mother_fuker', 'baz', 'dkjfj']

In [15]:  

pop() 方法将指定位置内容移除 并返回内容
In [14]: b_list                                        
Out[14]: ['foo', 'red', 'mother_fuker', 'baz', 'dkjfj']

In [15]: b_list.pop(1)                                 
Out[15]: 'red'

In [16]: b_list                                        
Out[16]: ['foo', 'mother_fuker', 'baz', 'dkjfj']

remove() 方法 将定位第一个符合要求的值 并移除
In [16]: b_list                                        
Out[16]: ['foo', 'mother_fuker', 'baz', 'dkjfj']

In [17]: b_list.remove('mother_fuker')                 

In [18]: b_list                                        
Out[18]: ['foo', 'baz', 'dkjfj']

in 关键字 检查一个值是否在列表中
In [18]: b_list                                        
Out[18]: ['foo', 'baz', 'dkjfj']

In [19]: 'baz' in b_list                               
Out[19]: True

In [20]: 'son_of_a_bitch' in b_list                    
Out[20]: False

检查列表是否包含一个指定值时非常缓慢的（python 在列表中进行了线性逐个扫描）
在字典和集合中 是同时检查所有元素（基于哈希表）

+ 链接连个列表
extend() 向列表添加多个元素
In [21]: x = [4,None,'foo']                            

In [22]: x.extend([7,8,(2,3)])                         

In [23]: x                                             
Out[23]: [4, None, 'foo', 7, 8, (2, 3)]
tips:使用 + 是相对高代价的操作 链接过程中创建了新的列表 并且复制了对象
使用extend将元素添加到已经存在的列表无需创建新的列表 并且复制对象

排序
sort() 方法
In [24]: a = [23,1,14,56]                              

In [25]: a.sort()                                      

In [26]: a                                             
Out[26]: [1, 14, 23, 56]

In [27]:                                               

sort() 参数示例
In [27]: b = ['asd','dfgfhhhh','sdfgh','s','df']       

In [28]: b.sort(key=len)                               

In [29]: b                                             
Out[29]: ['s', 'df', 'asd', 'sdfgh', 'dfgfhhhh']

In [30]:       
二分搜索和已排序列表的维护
bisect 模块实现二分搜索和已排序列表插值
bisect.bisect 找到应当被插入的位置并保持序列排序
bisect.insort 将元素插入到相应位置

 In [31]: import bisect                                                        

In [32]: c = [1,2,3,3,4,6]                                                    

In [33]: bisect.bisect(c,2)                                                   
Out[33]: 2

In [34]: bisect.bisect(c,4)                                                   
Out[34]: 5

In [35]: bisect.insort(c,6)                                                   

In [36]: c                                                                    
Out[36]: [1, 2, 3, 3, 4, 6, 6]

bisect模块不会检查列表是否已经排序，对没有排序的裂变使用bisect函数不会报错但是会导致错误结果

切片
形式：[start:stop]
In [36]: c                                                                    
Out[36]: [1, 2, 3, 3, 4, 6, 6]

In [37]: c[1:5]                                                               
Out[37]: [2, 3, 3, 4]

切片可以将序列赋值给变量
In [36]: c                                                                    
Out[36]: [1, 2, 3, 3, 4, 6, 6]

In [37]: c[1:5]                                                               
Out[37]: [2, 3, 3, 4]

In [38]: c[1:2] = [3]                                                         

In [39]: c                                                                    
Out[39]: [1, 3, 3, 3, 4, 6, 6]

tips:切片区间是左闭右开
start 和 stop 可以省略 如果省略会默认传入序列的开始位置或者结束位置
In [39]: c                                                                    
Out[39]: [1, 3, 3, 3, 4, 6, 6]

In [40]: c[:12]                                                               
Out[40]: [1, 3, 3, 3, 4, 6, 6]

In [41]: c[:3]                                                                
Out[41]: [1, 3, 3]

In [42]: c[:]                                                                 
Out[42]: [1, 3, 3, 3, 4, 6, 6]



负索引从序列尾部开始进行索引

In [43]: c[-1:]                                                               
Out[43]: [6]

In [44]: c[-1]                                                                
Out[44]: 6

In [45]: c[-4:]                                                               
Out[45]: [3, 4, 6, 6]

步长 step 在第二个冒号后使用 ，每隔多少个数取一个值

In [47]: c                                                                    
Out[47]: [1, 3, 3, 3, 4, 6, 6]

In [48]: c[::2]                                                               
Out[48]: [1, 3, 4, 6]

当需要对列表或者元组进行翻转时 就使得步长 -1
In [49]: c[::-1]                                                              
Out[49]: [6, 6, 4, 3, 3, 3, 1]

In [50]: c                                                                    
Out[50]: [1, 3, 3, 3, 4, 6, 6]

内建序列函数

enumerate
在遍历一个序列的同时追踪当前元素的索引
需要对数据建立索引时，一种有效模式就是使用enumrate构造一个字典 将序列值映射到索引位置上
In [51]: some_list =['foo','bar','baz']                                       

In [52]: mapping = {}                                                         

In [53]: for i,v in enumerate(some_list): 
    ...:     mapping[v] = i 
    ...:                                                                      

In [54]: mapping                                                              
Out[54]: {'foo': 0, 'bar': 1, 'baz': 2}


sorted
返回一个根据任意序列中元素新建的已排序列表
In [56]: sorted([7,1,2,6,0,3,2])                                              
Out[56]: [0, 1, 2, 2, 3, 6, 7]

In [57]: sorted('horse race')                                                 
Out[57]: [' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']

In [58]:  
tips: sorted为python内置函数 sort 为列表函数

zip 
zip 将列表 元组 或者其他序列的元素配对 新建一个元组构成的列表
zip可以处理任意长度序列 列表长度有最短的序列决定
In [66]: seq3 = ['false','true']                                              

In [67]: zipped1 = zip(seq1,seq2,seq3)                                        

In [68]: list(zipped1)                                                        
Out[68]: [('foo', 'one', 'false'), ('bar', 'two', 'true')]

zip 可是与enumerate 结合起来

In [69]: for i,(a,b) in enumerate(zip(seq1,seq2)): 
    ...:     print('{0}:{1},{2}'.format(i,a,b)) 
    ...:                                                                      
0:foo,one
1:bar,two
2:baz,three

zip(*name) 解压缩
In [78]: list(zipped)                                                         
Out[78]: [('one', 'foo'), ('two', 'bar'), ('three', 'baz')]

In [79]: zipped                                                               
Out[79]: <zip at 0x7f73be5bd488>

In [80]: list(zipped)                                                         
Out[80]: []

In [81]: zipped = zip(seq2,seq1)                                              

In [82]: first_row , last_row = zip(*zipped)                                  

In [83]: first_row                                                            
Out[83]: ('one', 'two', 'three')

In [84]: last_row                                                             
Out[84]: ('foo', 'bar', 'baz')


reversed 将序列元素倒序排列
tips：reversed 是一个生成器 如果没有实例化（list函数或者进行for循环）不会产生一个倒叙列表


*字典（最重要数据类型）
In [85]: d1 = {'a':'today is a happy day','b':12243}                          

In [86]: d1                                                                   
Out[86]: {'a': 'today is a happy day', 'b': 12243}

In [87]: d1['test_key'] = 'this is a test value'                              

In [88]: d1                                                                   
Out[88]: {'a': 'today is a happy day', 'b': 12243, 'test_key': 'this is a test value'}

In [90]: d1                                                                   
Out[90]: {'a': 'today is a happy day', 'b': 12243, 'test_key': 'this is a test value'}

del 删除指定key-value 对 
pop 删除指定key-value 对并且返回
In [91]: del d1['a']                                                          

In [92]: d1                                                                   
Out[92]: {'b': 12243, 'test_key': 'this is a test value'}

In [93]: ret = d1.pop('b')                                                    

In [94]: ret                                                                  
Out[94]: 12243

In [95]: d1                                                                   
Out[95]: {'test_key': 'this is a test value'}


keys()
values() 提供字典键值迭代器

In [95]: d1                                                                   
Out[95]: {'test_key': 'this is a test value'}

In [96]: d1['a'] = 'WTF'                                                      

In [97]: d1                                                                   
Out[97]: {'test_key': 'this is a test value', 'a': 'WTF'}
In [95]: d1                                                                   
Out[95]: {'test_key': 'this is a test value'}

In [96]: d1['a'] = 'WTF'                                                      

In [97]: d1                                                                   
Out[97]: {'test_key': 'this is a test value', 'a': 'WTF'}

update 将两个字典进行合并
In [102]: d1                                                                  
Out[102]: {'test_key': 'this is a test value', 'a': 'WTF'}

In [103]: d2 = {'i':211223 ,'b':'test'}                                       

In [104]: d1.update(d2)                                                       

In [105]: d1                                                                  
Out[105]: {'test_key': 'this is a test value', 'a': 'WTF', 'i': 211223, 'b': 'test'}



在序列生成字典
In [109]: mapping = dict(zip(range(5),reversed(range(5))))                    

In [110]: mapping                                                             
Out[110]: {0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
使用 zip进行配对 并使用dict 将配对成功的一一对应成为字典类型



In [111]: words = ['apple','bat','atom','but','bottle','araise','sex']        

In [112]: by_letters = {}   

In [114]: for word in words: 
     ...:     letter = word[0] 
     ...:     if letter not in by_letters: 
     ...:         by_letters[letter] = [word] 
     ...:     else: 
     ...:         by_letters[letter].append(word) 
     ...:                                                                     

In [115]: by_letters                                                          
Out[115]: {'a': ['apple', 'atom', 'araise'], 'b': ['bat', 'but', 'bottle'], 's': ['sex']}
<===========等价==============>

setdefault 作用
In [118]: by_letters = {}                                                     

In [119]: for word in words: 
     ...:     letter = word[0] 
     ...:     by_letters.setdefault(letter,[]).append(word) 
     ...:                                                                     

In [120]: by_letters                                                          
Out[120]: {'a': ['apple', 'atom', 'araise'], 'b': ['bat', 'but', 'bottle'], 's': ['sex']}
<=================等价=================>
from collections import defaultdict
by_letter = defaultdict(list)
for word in words：
    by_letter[word[0]].append(word)
内建的集合模块 defaultdict 向字典中对应位置传入相对应的值









if key in some_dict:
  value = some_dict[key]
 else:
  value = default_value

<========等价========>

value = some_dict.get(key,default_value)
功能：将键在some_dict中的值放到value 如果key不在some_dict 中则将默认值给到value中


有效的字典键类型

字典的键必须是不可变对象 (标量 元组(元组内部所有的元素必须不可改变(1,2,3,[1,2,3])不可以hash化) )
检查一个对象是否是不可变对象或者是否可以作为字典的键则检查对象是否可以哈希化


In [122]: hash('string')                                                      
Out[122]: 3381153119113649058

In [123]: hash(1)                                                             
Out[123]: 1

In [124]: hash((1,2,4))                                                       
Out[124]: 2528502973976161366

In [125]: hash([1,2,3])                                                       
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-125-35e31e935e9e> in <module>
----> 1 hash([1,2,3])

TypeError: unhashable type: 'list'

由于list是可变的 hash化会出错

如果list类型想要作为字典的键 将list转换为tuple
d[tuple([1,2,3])] = 5
d
{[1,2,3]:5}

集合
集合是一种无序 元素唯一的容器 
创建方法
In [129]: set([1,2,3,4,5,3])                                                  
Out[129]: {1, 2, 3, 4, 5}

In [130]: {1,2,3,4,3,4,1}                                                     
Out[130]: {1, 2, 3, 4}

In [131]: {3,4,5,56,1,2,3,4,4,4,1,2}                                          
Out[131]: {1, 2, 3, 4, 5, 56}

集合支持 交集 并集 差集 对称差集

In [133]: a = {1,2,3,4,5,6}                                                   

In [134]: b = {2,3,4,5,9}                                                     

In [135]: a.union(b)                                                          
Out[135]: {1, 2, 3, 4, 5, 6, 9}

In [136]: a                                                                   
Out[136]: {1, 2, 3, 4, 5, 6}

In [137]: a | b                                                               
Out[137]: {1, 2, 3, 4, 5, 6, 9}

In [138]: a & b                                                               
Out[138]: {2, 3, 4, 5}

In [139]: a.intersection(b)                                                   
Out[139]: {2, 3, 4, 5}


集合函数
 a.add(x) --------------------向a集合中添加x元素
 a.clear()--------------------将a集合重置为空
 a.remove(x)------------------从集合中删除某个元素
 a.pop()----------------------移除任意元素，如果集合是空的抛出keyError
 a.union(b)-------------------a | b a和b中的所有不同的元素 并集
 a.update(b)------------------a |= b 将a设置为a与b的并集
 a.intersection(b)------------a&b 交集
 a.intersection_update(b)-----a&=b 将a设置为a与b的交集内容
 a.difference(b)--------------a-b 在a不在b中的元素
 a.difference_update(b)-------a-=b 将a设置为在a不再b中的元素
 a.symmetric_difference(b)----a^b所有在a或b中，但是不是同时在a，b中的元素
 a.symmetric_difference_update(b) a^=b 将a设置为所有在a或b中的元素
 a.issubset(b)-----------------判断a是否为b的子集
 a.issuperset(b)---------------判断a是否为b的超集
 a.isdisjoint(b)---------------判断a,b是否没有交集
集合的元素类型必须是不可变的和字典类似

list set dict 的推导式
  推导式允许过滤一个容器的元素
  [expr for val in collection if condition]
  <============等价于=============>
  result = []
  for val in collection:
    if conditon:
      result.append(expr)
      
      
In [141]: string = ['a','as','bat','car','dove','python']                     

In [142]: [x.upper() for  x in string if len(x)>2]                            
Out[142]: ['BAT', 'CAR', 'DOVE', 'PYTHON']


字典推导式

dict_comp = {key-expr:value-expr for value in collection if conditon}

<===================等价于=====================>
result = {}
for key,value in collection:
  if condition :
    result[key] = value

集合推导式

set_comp = {expr for value in collection if condition }
<====================等价于======================>
set = {}
for value in collection:
  if conditon:
    result.add(expr)
    
求集合各个元素长度 并且放到一个集合内
In [143]: unique_lengths = {len(x) for x in string}                           

In [144]: unique_lengths                                                      
Out[144]: {1, 2, 3, 4, 6}
<====================等价于============================>
set(map(len,string))
map函数
map() 会根据提供的函数对指定序列做映射。
第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。

嵌套列表推导式

In [4]: all_data = [['Jone','Emily','Michael','Mary','Steven'],['Maria','Juan','Javier','Natalia','Pilar']]     

In [5]: names_of_interest = []                                                                                  

In [6]: for names in all_data: 
   ...:     enough_es = [name for name in names if name.count('e') >= 2] 
   ...:     names_of_interest.extend(enough_es) 
   ...:                                                                                                         
<======================等价于===============================>

In [7]: result = [name for names in all_data for name in names if name.count('e') >= 2]                         

In [8]: result                                                                                                  
Out[8]: ['Steven']

In [9]: names_of_interest                                                                                       
Out[9]: ['Steven']


In [11]: some_tuples = [(1,2,3),(4,5,6),(7,8,9)]                                                                

In [12]: flattended = [x for tup in some_tuples for x in tup]                                                   

In [13]: flattended                                                                                             
Out[13]: [1, 2, 3, 4, 5, 6, 7, 8, 9]

<===============等价于=================>
In [17]: for tups in some_tuples: 
    ...:     for x in tups: 
    ...:         flattended.append(x) 
    ...:          
    ...:                                                                                                        

In [18]: flattended                                                                                             
Out[18]: [1, 2, 3, 4, 5, 6, 7, 8, 9]


函数

In [21]: def my_function(x,y,z=1.5): 
    ...:     if z > 1: 
    ...:         return z*(x+y) 
    ...:     else: 
    ...:         return z/(x+y) 
    ...:                                                                                                        

In [22]: my_function                                                                                            
Out[22]: <function __main__.my_function(x, y, z=1.5)>

In [23]: my_function(5,6)                                                                                       
Out[23]: 16.5

In [24]: my_function(5,6,7)                                                                                     
Out[24]: 77


命名空间 作用域 本地函数

函数有两种连接变量的方式：全局 本地

In [26]: def func(): 
    ...:     a = [] 
    ...:     for i in range(5): 
    ...:         a.append(i) 
    ...:                                                                                                        

In [27]: func                                                                                                   
Out[27]: <function __main__.func()>

In [28]: a                                                                                                      
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-28-3f786850e387> in <module>
----> 1 a

NameError: name 'a' is not defined
<===============================>
此处a为本地（局部）变量 跳出func()函数就会销毁
使用global 关键字声明为全局变量]
如果global关键字在程序文件内大量使用 需要使用面向面向对象编程（使用类）


返回多个值的时候 默认返回的是一个元组

可以设置返回值为字典型
def f():
 a = 5
 b = 6
 c = 7
 return {'a':a,'b':b,'c':c}
 
函数是对象

In [47]: states = ['  Alabama','Georgial!','Georgia','georgia','F1OiIda','south   carolina##','West virginia?'] 

In [48]: def clean_strings(strings): 
    ...:     result = [] 
    ...:     for value in strings: 
    ...:         value = value.strip() #删除字符串左边和右边的空格
    ...:         value = re.sub('[!#?]','',value) #正则化
    ...:         value = value.title() #将字符串首字母变为大写
    ...:         result.append(value) 
    ...:     return result 
    ...:      
    ...:                                                                                                        

In [49]: clean_strings(states)                                                                                  
Out[49]: 
['Alabama',
 'Georgial',
 'Georgia',
 'Georgia',
 'F1Oiida',
 'South   Carolina',
 'West Virginia']




匿名（Lamba）函数
匿名函数是通过单个语句生成函数的方式 结果是返回值

In [72]: strings = ['foo','card','bar','aaaa','abab']                                                           

In [73]: strings.sort(key=lambda x :len(set(list(x))))                                                          

In [74]: strings                                                                                                
Out[74]: ['aaaa', 'foo', 'abab', 'bar', 'card']

柯里化：表示通过部分参数应用的方式 从已有的函数中衍生出新的函数 

def add_number(x,y):
  return x+y

add_five = lambda y : add_number(5,y) 通过已经存在的add_number函数衍生出新的函数

functools 模块使用 pratial 函数简化处理
In [75]: from functools import partial                                                                          

In [76]: def add_number(x,y)                                                                                    
  File "<ipython-input-76-27c15c6b9dd4>", line 1
    def add_number(x,y)
                       ^
SyntaxError: invalid syntax


In [77]: def add_number(x,y): 
    ...:     return x+y 
    ...:                                                                                                        

In [78]: add_five = lambda y : add_number(5,y)                                                                  

In [79]: add_five(4)                                                                                            
Out[79]: 9

In [80]: add_six = partial(add_number,6)                                                                        

In [81]: add_six(5)                                                                                             
Out[81]: 11


生成器：
通过一致的方式遍历序列 
迭代器协议是一种令对象可遍历的通用方式
for key in some_dict:
  print(key)
当读入到for key in some_dict:语句时 python 解释器首先尝试根据some_dict 生成一个迭代器
dict_iterator = iter(some_dict)
dict_iterator

生成器
返回一个多结果的序列，在每一个元素产生后暂停 直到下一个请求 
若需要创建一个生成器 将return关键字换成 yield


In [88]: def squares(n=10): 
    ...:     print('Generating squares from 1 to {0}'.format(n**2)) 
    ...:     for i in range(1,n+1): 
    ...:         yield i**2 
    ...:                                                                                                        

In [89]: gen = squares()                                                                                        

In [90]: gen                                                                                                    
Out[90]: <generator object squares at 0x7fdf7c7e6e60>

In [91]: for x in gen : 
    ...:     print(x,end=' ') 
    ...:                                                                                                        
Generating squares from 1 to 100
1 4 9 16 25 36 49 64 81 100 

调用生成器时候 代码不会立即执行，直到请求生成器中的元素时候 才会执行代码

生成器表达式:
gen = (x**2 for x in range(10))
<=============等价于===================>
In [88]: def squares(n=10): 
    ...:     print('Generating squares from 1 to {0}'.format(n**2)) 
    ...:     for i in range(1,n+1): 
    ...:         yield i**2 
    ...:                                                                                                        
生成器表达式可以作为函数参数用于替代列表推导式

In [102]: sum(x**2 for x in range(100))                                                                         
Out[102]: 328350

In [103]: dict((i,i**2) for i in range(5))                                                                      
Out[103]: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

itertools 模块:适用于大多数数据算法的生成器集合 
In [104]: import itertools                                                                                      

In [105]: first_letter = lambda x:x[0]                                                                          

In [106]: names = ['Alan','Adam','Wes','Will','Albert','Steven']                                                

In [107]: for letter,names in itertools.groupby(names,first_letter): 
     ...:     print(letter,list(names)) 
     ...:                                                                                                       
A ['Alan', 'Adam']
W ['Wes', 'Will']
A ['Albert']
S ['Steven']

有用的itertools函数
combinations(iterable,k)  根据iterable参数中所有元素生成一个包含所有可能 K-元组的序列 忽略元素的顺序 也不进行替代
permutations(iterable,k) 根据iterable参数中的所有元素按顺序生成包含所有可能k元组的序列
groupby(iterable[,keyfunc]) 根据每一个独一的key生成（key,sub-iterator）元组
product(*iterables,repeat=1) 以元组的形式 根据输入的可遍历对象生成笛卡尔积 与嵌套的for循环类似

错误与异常处理

可以通过将会抛出异常的函数写入到try/except 代码段中
In [109]: def attempt_float(x): 
     ...:     try: 
     ...:         return float(x) 
     ...:     except: 
     ...:         return x 
     ...:                                                                                                       

In [110]: attempt_float(1.234)                                                                                  
Out[110]: 1.234

In [111]: attempt_float(1)                                                                                      
Out[111]: 1.0

In [112]: attempt_float('124')                                                                                  
Out[112]: 124.0

In [113]: attempt_float('some_thing')                                                                           
Out[113]: 'some_thing'

若float(x)出现异常 则执行except中的语句

可以通过将多个异常类型写成元组的形式 同时捕获多个异常

In [114]: def attempt_float(x): 
     ...:     try: 
     ...:         return float(x) 
     ...:     except (TypeError,ValueError): 
     ...:         return x 


无论try部分是否抛出错误都要执行
finally语句
f = open(path,'w')
try:
 write_to_file(f)
finally:
 f.close()

文件与操作系统

打开文件
path == 'examples/segismundo.txt'
f = open(path)

for line in f:
 pass
 
在使用open语句创建文件对象时 在结束操作时候显式的关闭文件
f.close()
使用with语句，文件会在with代码块结束后自动关闭文件

with open(path) as f；
 lines = [x.rstrip() for x in f]
 
字节与Unicode 文件

data.decode('utf-8') 解码


numpy 基础 数组和向量化计算


numpy ndarray :多维数组对象

numpy 核心特征之一就是N维数组对象 ndarray  -------大型数据集容器


In [116]: import numpy as np                                                                                    

In [117]: data = np.random.randn(2,3)                                                                           

In [118]: data                                                                                                  
Out[118]: 
array([[ 0.7739898 ,  1.03867592,  0.12782728],
       [-0.40561562,  0.6259303 , -0.71695792]])

In [119]: data.shape #返回矩阵行列数量信息                                                                                           
Out[119]: (2, 3)

In [120]: data.dtype #返回各个元素的类型                                                                                           
Out[120]: dtype('float64')

生成ndarray 
生成数组最简单的方式就是使用array函数

In [121]: data1 = [6,7.5,8,0,1]                                                                                 

In [122]: arr1 = np.array(data1)                                                                                

In [123]: arr1                                                                                                  
Out[123]: array([6. , 7.5, 8. , 0. , 1. ])

嵌套序列会自动转换成多维数组
In [125]: data2 = [[1,2,3,4],[5,6,7,8]]                                                                         

In [126]: arr2 = np.array(data2)                                                                                

In [127]: arr2                                                                                                  
Out[127]: 
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])

np.array 会自动推断生成数组的数据类型

In [130]: arr1.dtype                                                                                            
Out[130]: dtype('float64')

In [131]: arr2.dtype                                                                                            
Out[131]: dtype('int64')

np.zeros() 给定长度与形状后 可以一次性创造全0 数组
np.ones() 可以一次性创造全1 数组

np.empty() 可以创建一个没有初始值的数组 有时候返回的是垃圾数据 并非为空 
想要创建新的高维数组 需要为shape传递一个元组


In [146]: np.identity(4)                                                                                        
Out[146]: 
array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])

In [147]: np.eye(3)                                                                                             
Out[147]: 
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

astype 方法显式转换数组
In [149]: arr = np.array([1,2,3,4,5])                                                                           

In [150]: arr.dtype                                                                                             
Out[150]: dtype('int64')

In [151]: float_arr = arr.astype(np.float64)                                                                    

In [152]: float_arr                                                                                             
Out[152]: array([1., 2., 3., 4., 5.])

In [153]: float_arr.dtype()                                                                                     
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-153-825e49b691ad> in <module>
----> 1 float_arr.dtype()

TypeError: 'numpy.dtype' object is not callable

In [154]: float_arr.dtype                                                                                       
Out[154]: dtype('float64')



































































