
列表
列表长度可变 包含内容可以修改
In [1]: a_list = [1,2,3,None]                          

In [2]: tup = ('foo','bar','baz')                      

In [3]: b_list = list(tup)                             

In [4]: b_list                                         
Out[4]: ['foo', 'bar', 'baz']

In [5]: b_list[1] = 'mother_fuker'                     

In [6]: b_list                                         
Out[6]: ['foo', 'mother_fuker', 'baz']

In [7]:  

list 函数在数据处理中常用于 迭代器 或者生成器转化为列表
In [7]: gen = range(10)                                

In [8]: gen                                            
Out[8]: range(0, 10)

In [9]: list(gen)                                      
Out[9]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [10]:                                               

append() 方法在结尾添加内容
insert() 方法在指定位置添加内容

In [11]: b_list.append('dkjfj')                        

In [12]: b_list                                        
Out[12]: ['foo', 'mother_fuker', 'baz', 'dkjfj']

In [13]: b_list.insert(1,'red')                        

In [14]: b_list                                        
Out[14]: ['foo', 'red', 'mother_fuker', 'baz', 'dkjfj']

In [15]:  

pop() 方法将指定位置内容移除 并返回内容
In [14]: b_list                                        
Out[14]: ['foo', 'red', 'mother_fuker', 'baz', 'dkjfj']

In [15]: b_list.pop(1)                                 
Out[15]: 'red'

In [16]: b_list                                        
Out[16]: ['foo', 'mother_fuker', 'baz', 'dkjfj']

remove() 方法 将定位第一个符合要求的值 并移除
In [16]: b_list                                        
Out[16]: ['foo', 'mother_fuker', 'baz', 'dkjfj']

In [17]: b_list.remove('mother_fuker')                 

In [18]: b_list                                        
Out[18]: ['foo', 'baz', 'dkjfj']

in 关键字 检查一个值是否在列表中
In [18]: b_list                                        
Out[18]: ['foo', 'baz', 'dkjfj']

In [19]: 'baz' in b_list                               
Out[19]: True

In [20]: 'son_of_a_bitch' in b_list                    
Out[20]: False

检查列表是否包含一个指定值时非常缓慢的（python 在列表中进行了线性逐个扫描）
在字典和集合中 是同时检查所有元素（基于哈希表）

+ 链接连个列表
extend() 向列表添加多个元素
In [21]: x = [4,None,'foo']                            

In [22]: x.extend([7,8,(2,3)])                         

In [23]: x                                             
Out[23]: [4, None, 'foo', 7, 8, (2, 3)]
tips:使用 + 是相对高代价的操作 链接过程中创建了新的列表 并且复制了对象
使用extend将元素添加到已经存在的列表无需创建新的列表 并且复制对象

排序
sort() 方法
In [24]: a = [23,1,14,56]                              

In [25]: a.sort()                                      

In [26]: a                                             
Out[26]: [1, 14, 23, 56]

In [27]:                                               

sort() 参数示例
In [27]: b = ['asd','dfgfhhhh','sdfgh','s','df']       

In [28]: b.sort(key=len)                               

In [29]: b                                             
Out[29]: ['s', 'df', 'asd', 'sdfgh', 'dfgfhhhh']

In [30]:       
二分搜索和已排序列表的维护
bisect 模块实现二分搜索和已排序列表插值
bisect.bisect 找到应当被插入的位置并保持序列排序
bisect.insort 将元素插入到相应位置

 In [31]: import bisect                                                        

In [32]: c = [1,2,3,3,4,6]                                                    

In [33]: bisect.bisect(c,2)                                                   
Out[33]: 2

In [34]: bisect.bisect(c,4)                                                   
Out[34]: 5

In [35]: bisect.insort(c,6)                                                   

In [36]: c                                                                    
Out[36]: [1, 2, 3, 3, 4, 6, 6]

bisect模块不会检查列表是否已经排序，对没有排序的裂变使用bisect函数不会报错但是会导致错误结果

切片
形式：[start:stop]
In [36]: c                                                                    
Out[36]: [1, 2, 3, 3, 4, 6, 6]

In [37]: c[1:5]                                                               
Out[37]: [2, 3, 3, 4]

切片可以将序列赋值给变量
In [36]: c                                                                    
Out[36]: [1, 2, 3, 3, 4, 6, 6]

In [37]: c[1:5]                                                               
Out[37]: [2, 3, 3, 4]

In [38]: c[1:2] = [3]                                                         

In [39]: c                                                                    
Out[39]: [1, 3, 3, 3, 4, 6, 6]

tips:切片区间是左闭右开
start 和 stop 可以省略 如果省略会默认传入序列的开始位置或者结束位置
In [39]: c                                                                    
Out[39]: [1, 3, 3, 3, 4, 6, 6]

In [40]: c[:12]                                                               
Out[40]: [1, 3, 3, 3, 4, 6, 6]

In [41]: c[:3]                                                                
Out[41]: [1, 3, 3]

In [42]: c[:]                                                                 
Out[42]: [1, 3, 3, 3, 4, 6, 6]



负索引从序列尾部开始进行索引

In [43]: c[-1:]                                                               
Out[43]: [6]

In [44]: c[-1]                                                                
Out[44]: 6

In [45]: c[-4:]                                                               
Out[45]: [3, 4, 6, 6]

步长 step 在第二个冒号后使用 ，每隔多少个数取一个值

In [47]: c                                                                    
Out[47]: [1, 3, 3, 3, 4, 6, 6]

In [48]: c[::2]                                                               
Out[48]: [1, 3, 4, 6]

当需要对列表或者元组进行翻转时 就使得步长 -1
In [49]: c[::-1]                                                              
Out[49]: [6, 6, 4, 3, 3, 3, 1]

In [50]: c                                                                    
Out[50]: [1, 3, 3, 3, 4, 6, 6]

内建序列函数

enumerate
在遍历一个序列的同时追踪当前元素的索引
需要对数据建立索引时，一种有效模式就是使用enumrate构造一个字典 将序列值映射到索引位置上
In [51]: some_list =['foo','bar','baz']                                       

In [52]: mapping = {}                                                         

In [53]: for i,v in enumerate(some_list): 
    ...:     mapping[v] = i 
    ...:                                                                      

In [54]: mapping                                                              
Out[54]: {'foo': 0, 'bar': 1, 'baz': 2}


sorted
返回一个根据任意序列中元素新建的已排序列表
In [56]: sorted([7,1,2,6,0,3,2])                                              
Out[56]: [0, 1, 2, 2, 3, 6, 7]

In [57]: sorted('horse race')                                                 
Out[57]: [' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']

In [58]:  
tips: sorted为python内置函数 sort 为列表函数

zip 
zip 将列表 元组 或者其他序列的元素配对 新建一个元组构成的列表
zip可以处理任意长度序列 列表长度有最短的序列决定
In [66]: seq3 = ['false','true']                                              

In [67]: zipped1 = zip(seq1,seq2,seq3)                                        

In [68]: list(zipped1)                                                        
Out[68]: [('foo', 'one', 'false'), ('bar', 'two', 'true')]

zip 可是与enumerate 结合起来

In [69]: for i,(a,b) in enumerate(zip(seq1,seq2)): 
    ...:     print('{0}:{1},{2}'.format(i,a,b)) 
    ...:                                                                      
0:foo,one
1:bar,two
2:baz,three

zip(*name) 解压缩
In [78]: list(zipped)                                                         
Out[78]: [('one', 'foo'), ('two', 'bar'), ('three', 'baz')]

In [79]: zipped                                                               
Out[79]: <zip at 0x7f73be5bd488>

In [80]: list(zipped)                                                         
Out[80]: []

In [81]: zipped = zip(seq2,seq1)                                              

In [82]: first_row , last_row = zip(*zipped)                                  

In [83]: first_row                                                            
Out[83]: ('one', 'two', 'three')

In [84]: last_row                                                             
Out[84]: ('foo', 'bar', 'baz')


reversed 将序列元素倒序排列
tips：reversed 是一个生成器 如果没有实例化（list函数或者进行for循环）不会产生一个倒叙列表


*字典（最重要数据类型）
In [85]: d1 = {'a':'today is a happy day','b':12243}                          

In [86]: d1                                                                   
Out[86]: {'a': 'today is a happy day', 'b': 12243}

In [87]: d1['test_key'] = 'this is a test value'                              

In [88]: d1                                                                   
Out[88]: {'a': 'today is a happy day', 'b': 12243, 'test_key': 'this is a test value'}

In [90]: d1                                                                   
Out[90]: {'a': 'today is a happy day', 'b': 12243, 'test_key': 'this is a test value'}

del 删除指定key-value 对 
pop 删除指定key-value 对并且返回
In [91]: del d1['a']                                                          

In [92]: d1                                                                   
Out[92]: {'b': 12243, 'test_key': 'this is a test value'}

In [93]: ret = d1.pop('b')                                                    

In [94]: ret                                                                  
Out[94]: 12243

In [95]: d1                                                                   
Out[95]: {'test_key': 'this is a test value'}


keys()
values() 提供字典键值迭代器

In [95]: d1                                                                   
Out[95]: {'test_key': 'this is a test value'}

In [96]: d1['a'] = 'WTF'                                                      

In [97]: d1                                                                   
Out[97]: {'test_key': 'this is a test value', 'a': 'WTF'}
In [95]: d1                                                                   
Out[95]: {'test_key': 'this is a test value'}

In [96]: d1['a'] = 'WTF'                                                      

In [97]: d1                                                                   
Out[97]: {'test_key': 'this is a test value', 'a': 'WTF'}

update 将两个字典进行合并
In [102]: d1                                                                  
Out[102]: {'test_key': 'this is a test value', 'a': 'WTF'}

In [103]: d2 = {'i':211223 ,'b':'test'}                                       

In [104]: d1.update(d2)                                                       

In [105]: d1                                                                  
Out[105]: {'test_key': 'this is a test value', 'a': 'WTF', 'i': 211223, 'b': 'test'}



在序列生成字典
In [109]: mapping = dict(zip(range(5),reversed(range(5))))                    

In [110]: mapping                                                             
Out[110]: {0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
使用 zip进行配对 并使用dict 将配对成功的一一对应成为字典类型



In [111]: words = ['apple','bat','atom','but','bottle','araise','sex']        

In [112]: by_letters = {}   

In [114]: for word in words: 
     ...:     letter = word[0] 
     ...:     if letter not in by_letters: 
     ...:         by_letters[letter] = [word] 
     ...:     else: 
     ...:         by_letters[letter].append(word) 
     ...:                                                                     

In [115]: by_letters                                                          
Out[115]: {'a': ['apple', 'atom', 'araise'], 'b': ['bat', 'but', 'bottle'], 's': ['sex']}
<===========等价==============>

setdefault 作用
In [118]: by_letters = {}                                                     

In [119]: for word in words: 
     ...:     letter = word[0] 
     ...:     by_letters.setdefault(letter,[]).append(word) 
     ...:                                                                     

In [120]: by_letters                                                          
Out[120]: {'a': ['apple', 'atom', 'araise'], 'b': ['bat', 'but', 'bottle'], 's': ['sex']}
<=================等价=================>
from collections import defaultdict
by_letter = defaultdict(list)
for word in words：
    by_letter[word[0]].append(word)
内建的集合模块 defaultdict 向字典中对应位置传入相对应的值









if key in some_dict:
  value = some_dict[key]
 else:
  value = default_value

<========等价========>

value = some_dict.get(key,default_value)
功能：将键在some_dict中的值放到value 如果key不在some_dict 中则将默认值给到value中


有效的字典键类型

字典的键必须是不可变对象 (标量 元组(元组内部所有的元素必须不可改变(1,2,3,[1,2,3])不可以hash化) )
检查一个对象是否是不可变对象或者是否可以作为字典的键则检查对象是否可以哈希化


In [122]: hash('string')                                                      
Out[122]: 3381153119113649058

In [123]: hash(1)                                                             
Out[123]: 1

In [124]: hash((1,2,4))                                                       
Out[124]: 2528502973976161366

In [125]: hash([1,2,3])                                                       
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-125-35e31e935e9e> in <module>
----> 1 hash([1,2,3])

TypeError: unhashable type: 'list'

由于list是可变的 hash化会出错

如果list类型想要作为字典的键 将list转换为tuple
d[tuple([1,2,3])] = 5
d
{[1,2,3]:5}

集合
集合是一种无序 元素唯一的容器 
创建方法
In [129]: set([1,2,3,4,5,3])                                                  
Out[129]: {1, 2, 3, 4, 5}

In [130]: {1,2,3,4,3,4,1}                                                     
Out[130]: {1, 2, 3, 4}

In [131]: {3,4,5,56,1,2,3,4,4,4,1,2}                                          
Out[131]: {1, 2, 3, 4, 5, 56}

集合支持 交集 并集 差集 对称差集

In [133]: a = {1,2,3,4,5,6}                                                   

In [134]: b = {2,3,4,5,9}                                                     

In [135]: a.union(b)                                                          
Out[135]: {1, 2, 3, 4, 5, 6, 9}

In [136]: a                                                                   
Out[136]: {1, 2, 3, 4, 5, 6}

In [137]: a | b                                                               
Out[137]: {1, 2, 3, 4, 5, 6, 9}

In [138]: a & b                                                               
Out[138]: {2, 3, 4, 5}

In [139]: a.intersection(b)                                                   
Out[139]: {2, 3, 4, 5}


集合函数
 a.add(x) --------------------向a集合中添加x元素
 a.clear()--------------------将a集合重置为空
 a.remove(x)------------------从集合中删除某个元素
 a.pop()----------------------移除任意元素，如果集合是空的抛出keyError
 a.union(b)-------------------a | b a和b中的所有不同的元素 并集
 a.update(b)------------------a |= b 将a设置为a与b的并集
 a.intersection(b)------------a&b 交集
 a.intersection_update(b)-----a&=b 将a设置为a与b的交集内容
 a.difference(b)--------------a-b 在a不在b中的元素
 a.difference_update(b)-------a-=b 将a设置为在a不再b中的元素
 a.symmetric_difference(b)----a^b所有在a或b中，但是不是同时在a，b中的元素
 a.symmetric_difference_update(b) a^=b 将a设置为所有在a或b中的元素
 a.issubset(b)-----------------判断a是否为b的子集
 a.issuperset(b)---------------判断a是否为b的超集
 a.isdisjoint(b)---------------判断a,b是否没有交集
集合的元素类型必须是不可变的和字典类似

list set dict 的推导式
  推导式允许过滤一个容器的元素
  [expr for val in collection if condition]
  <============等价于=============>
  result = []
  for val in collection:
    if conditon:
      result.append(expr)
      
      
In [141]: string = ['a','as','bat','car','dove','python']                     

In [142]: [x.upper() for  x in string if len(x)>2]                            
Out[142]: ['BAT', 'CAR', 'DOVE', 'PYTHON']


字典推导式

dict_comp = {key-expr:value-expr for value in collection if conditon}

<===================等价于=====================>
result = {}
for key,value in collection:
  if condition :
    result[key] = value

集合推导式

set_comp = {expr for value in collection if condition }
<====================等价于======================>
set = {}
for value in collection:
  if conditon:
    result.add(expr)
    
求集合各个元素长度 并且放到一个集合内
In [143]: unique_lengths = {len(x) for x in string}                           

In [144]: unique_lengths                                                      
Out[144]: {1, 2, 3, 4, 6}
<====================等价于============================>
set(map(len,string))
map函数
map() 会根据提供的函数对指定序列做映射。
第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。

嵌套列表推导式

In [4]: all_data = [['Jone','Emily','Michael','Mary','Steven'],['Maria','Juan','Javier','Natalia','Pilar']]     

In [5]: names_of_interest = []                                                                                  

In [6]: for names in all_data: 
   ...:     enough_es = [name for name in names if name.count('e') >= 2] 
   ...:     names_of_interest.extend(enough_es) 
   ...:                                                                                                         
<======================等价于===============================>

In [7]: result = [name for names in all_data for name in names if name.count('e') >= 2]                         

In [8]: result                                                                                                  
Out[8]: ['Steven']

In [9]: names_of_interest                                                                                       
Out[9]: ['Steven']


In [11]: some_tuples = [(1,2,3),(4,5,6),(7,8,9)]                                                                

In [12]: flattended = [x for tup in some_tuples for x in tup]                                                   

In [13]: flattended                                                                                             
Out[13]: [1, 2, 3, 4, 5, 6, 7, 8, 9]

<===============等价于=================>
In [17]: for tups in some_tuples: 
    ...:     for x in tups: 
    ...:         flattended.append(x) 
    ...:          
    ...:                                                                                                        

In [18]: flattended                                                                                             
Out[18]: [1, 2, 3, 4, 5, 6, 7, 8, 9]


函数

In [21]: def my_function(x,y,z=1.5): 
    ...:     if z > 1: 
    ...:         return z*(x+y) 
    ...:     else: 
    ...:         return z/(x+y) 
    ...:                                                                                                        

In [22]: my_function                                                                                            
Out[22]: <function __main__.my_function(x, y, z=1.5)>

In [23]: my_function(5,6)                                                                                       
Out[23]: 16.5

In [24]: my_function(5,6,7)                                                                                     
Out[24]: 77


命名空间 作用域 本地函数

函数有两种连接变量的方式：全局 本地

In [26]: def func(): 
    ...:     a = [] 
    ...:     for i in range(5): 
    ...:         a.append(i) 
    ...:                                                                                                        

In [27]: func                                                                                                   
Out[27]: <function __main__.func()>

In [28]: a                                                                                                      
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-28-3f786850e387> in <module>
----> 1 a

NameError: name 'a' is not defined
<===============================>
此处a为本地（局部）变量 跳出func()函数就会销毁
使用global 关键字声明为全局变量]
如果global关键字在程序文件内大量使用 需要使用面向面向对象编程（使用类）


返回多个值的时候 默认返回的是一个元组

可以设置返回值为字典型
def f():
 a = 5
 b = 6
 c = 7
 return {'a':a,'b':b,'c':c}
 
函数是对象

In [47]: states = ['  Alabama','Georgial!','Georgia','georgia','F1OiIda','south   carolina##','West virginia?'] 

In [48]: def clean_strings(strings): 
    ...:     result = [] 
    ...:     for value in strings: 
    ...:         value = value.strip() #删除字符串左边和右边的空格
    ...:         value = re.sub('[!#?]','',value) #正则化
    ...:         value = value.title() #将字符串首字母变为大写
    ...:         result.append(value) 
    ...:     return result 
    ...:      
    ...:                                                                                                        

In [49]: clean_strings(states)                                                                                  
Out[49]: 
['Alabama',
 'Georgial',
 'Georgia',
 'Georgia',
 'F1Oiida',
 'South   Carolina',
 'West Virginia']




匿名（Lamba）函数
匿名函数是通过单个语句生成函数的方式 结果是返回值

In [72]: strings = ['foo','card','bar','aaaa','abab']                                                           

In [73]: strings.sort(key=lambda x :len(set(list(x))))                                                          

In [74]: strings                                                                                                
Out[74]: ['aaaa', 'foo', 'abab', 'bar', 'card']

柯里化：表示通过部分参数应用的方式 从已有的函数中衍生出新的函数 

def add_number(x,y):
  return x+y

add_five = lambda y : add_number(5,y) 通过已经存在的add_number函数衍生出新的函数

functools 模块使用 pratial 函数简化处理
In [75]: from functools import partial                                                                          

In [76]: def add_number(x,y)                                                                                    
  File "<ipython-input-76-27c15c6b9dd4>", line 1
    def add_number(x,y)
                       ^
SyntaxError: invalid syntax


In [77]: def add_number(x,y): 
    ...:     return x+y 
    ...:                                                                                                        

In [78]: add_five = lambda y : add_number(5,y)                                                                  

In [79]: add_five(4)                                                                                            
Out[79]: 9

In [80]: add_six = partial(add_number,6)                                                                        

In [81]: add_six(5)                                                                                             
Out[81]: 11


生成器：
通过一致的方式遍历序列 
迭代器协议是一种令对象可遍历的通用方式
for key in some_dict:
  print(key)
当读入到for key in some_dict:语句时 python 解释器首先尝试根据some_dict 生成一个迭代器
dict_iterator = iter(some_dict)
dict_iterator

生成器
返回一个多结果的序列，在每一个元素产生后暂停 直到下一个请求 
若需要创建一个生成器 将return关键字换成 yield


In [88]: def squares(n=10): 
    ...:     print('Generating squares from 1 to {0}'.format(n**2)) 
    ...:     for i in range(1,n+1): 
    ...:         yield i**2 
    ...:                                                                                                        

In [89]: gen = squares()                                                                                        

In [90]: gen                                                                                                    
Out[90]: <generator object squares at 0x7fdf7c7e6e60>

In [91]: for x in gen : 
    ...:     print(x,end=' ') 
    ...:                                                                                                        
Generating squares from 1 to 100
1 4 9 16 25 36 49 64 81 100 

调用生成器时候 代码不会立即执行，直到请求生成器中的元素时候 才会执行代码

生成器表达式:
gen = (x**2 for x in range(10))
<=============等价于===================>
In [88]: def squares(n=10): 
    ...:     print('Generating squares from 1 to {0}'.format(n**2)) 
    ...:     for i in range(1,n+1): 
    ...:         yield i**2 
    ...:                                                                                                        
生成器表达式可以作为函数参数用于替代列表推导式

In [102]: sum(x**2 for x in range(100))                                                                         
Out[102]: 328350

In [103]: dict((i,i**2) for i in range(5))                                                                      
Out[103]: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

itertools 模块:适用于大多数数据算法的生成器集合 
In [104]: import itertools                                                                                      

In [105]: first_letter = lambda x:x[0]                                                                          

In [106]: names = ['Alan','Adam','Wes','Will','Albert','Steven']                                                

In [107]: for letter,names in itertools.groupby(names,first_letter): 
     ...:     print(letter,list(names)) 
     ...:                                                                                                       
A ['Alan', 'Adam']
W ['Wes', 'Will']
A ['Albert']
S ['Steven']

有用的itertools函数
combinations(iterable,k)  根据iterable参数中所有元素生成一个包含所有可能 K-元组的序列 忽略元素的顺序 也不进行替代
permutations(iterable,k) 根据iterable参数中的所有元素按顺序生成包含所有可能k元组的序列
groupby(iterable[,keyfunc]) 根据每一个独一的key生成（key,sub-iterator）元组
product(*iterables,repeat=1) 以元组的形式 根据输入的可遍历对象生成笛卡尔积 与嵌套的for循环类似

错误与异常处理

可以通过将会抛出异常的函数写入到try/except 代码段中
In [109]: def attempt_float(x): 
     ...:     try: 
     ...:         return float(x) 
     ...:     except: 
     ...:         return x 
     ...:                                                                                                       

In [110]: attempt_float(1.234)                                                                                  
Out[110]: 1.234

In [111]: attempt_float(1)                                                                                      
Out[111]: 1.0

In [112]: attempt_float('124')                                                                                  
Out[112]: 124.0

In [113]: attempt_float('some_thing')                                                                           
Out[113]: 'some_thing'

若float(x)出现异常 则执行except中的语句

可以通过将多个异常类型写成元组的形式 同时捕获多个异常

In [114]: def attempt_float(x): 
     ...:     try: 
     ...:         return float(x) 
     ...:     except (TypeError,ValueError): 
     ...:         return x 


无论try部分是否抛出错误都要执行
finally语句
f = open(path,'w')
try:
 write_to_file(f)
finally:
 f.close()

文件与操作系统

打开文件
path == 'examples/segismundo.txt'
f = open(path)

for line in f:
 pass
 
在使用open语句创建文件对象时 在结束操作时候显式的关闭文件
f.close()
使用with语句，文件会在with代码块结束后自动关闭文件

with open(path) as f；
 lines = [x.rstrip() for x in f]
 
字节与Unicode 文件

data.decode('utf-8') 解码


numpy 基础 数组和向量化计算


numpy ndarray :多维数组对象

numpy 核心特征之一就是N维数组对象 ndarray  -------大型数据集容器


In [116]: import numpy as np                                                                                    

In [117]: data = np.random.randn(2,3)                                                                           

In [118]: data                                                                                                  
Out[118]: 
array([[ 0.7739898 ,  1.03867592,  0.12782728],
       [-0.40561562,  0.6259303 , -0.71695792]])

In [119]: data.shape #返回矩阵行列数量信息                                                                                           
Out[119]: (2, 3)

In [120]: data.dtype #返回各个元素的类型                                                                                           
Out[120]: dtype('float64')

生成ndarray 
生成数组最简单的方式就是使用array函数

In [121]: data1 = [6,7.5,8,0,1]                                                                                 

In [122]: arr1 = np.array(data1)                                                                                

In [123]: arr1                                                                                                  
Out[123]: array([6. , 7.5, 8. , 0. , 1. ])

嵌套序列会自动转换成多维数组
In [125]: data2 = [[1,2,3,4],[5,6,7,8]]                                                                         

In [126]: arr2 = np.array(data2)                                                                                

In [127]: arr2                                                                                                  
Out[127]: 
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])

np.array 会自动推断生成数组的数据类型

In [130]: arr1.dtype                                                                                            
Out[130]: dtype('float64')

In [131]: arr2.dtype                                                                                            
Out[131]: dtype('int64')

np.zeros() 给定长度与形状后 可以一次性创造全0 数组
np.ones() 可以一次性创造全1 数组

np.empty() 可以创建一个没有初始值的数组 有时候返回的是垃圾数据 并非为空 
想要创建新的高维数组 需要为shape传递一个元组


In [146]: np.identity(4)                                                                                        
Out[146]: 
array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])

In [147]: np.eye(3)                                                                                             
Out[147]: 
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

astype 方法显式转换数组
In [149]: arr = np.array([1,2,3,4,5])                                                                           

In [150]: arr.dtype                                                                                             
Out[150]: dtype('int64')

In [151]: float_arr = arr.astype(np.float64)                                                                    

In [152]: float_arr                                                                                             
Out[152]: array([1., 2., 3., 4., 5.])

In [153]: float_arr.dtype()                                                                                     
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-153-825e49b691ad> in <module>
----> 1 float_arr.dtype()

TypeError: 'numpy.dtype' object is not callable

In [154]: float_arr.dtype                                                                                       
Out[154]: dtype('float64')


numpy 数组算术
数组允许进行批量操作 不同for循环

In [4]: arr = np.array([[1,2,3],[4,5,6]])                                                                       

In [5]: arr                                                                                                     
Out[5]: 
array([[1, 2, 3],
       [4, 5, 6]])

In [6]: arr * arr                                                                                               
Out[6]: 
array([[ 1,  4,  9],
       [16, 25, 36]])

In [7]: arr - arr                                                                                               
Out[7]: 
array([[0, 0, 0],
       [0, 0, 0]])

In [8]: 1/arr                                                                                                   
Out[8]: 
array([[1.        , 0.5       , 0.33333333],
       [0.25      , 0.2       , 0.16666667]])

In [9]: arr ** 0.5                                                                                              
Out[9]: 
array([[1.        , 1.41421356, 1.73205081],
       [2.        , 2.23606798, 2.44948974]])

In [10]: arr2 = np.array()                 



In [13]: arr2                                                                                                   
Out[13]: 
array([[ 0,  4,  1],
       [ 7,  2, 12]])

In [15]: arr2 > arr                                                                                             
Out[15]: 
array([[False,  True, False],
       [ True, False,  True]])

基础索引 与 切片


In [16]: arr = np.arange(10)                                                                                    

In [17]: arr                                                                                                    
Out[17]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [18]: arr[5]                                                                                                 
Out[18]: 5

In [19]: arr[5:8]                                                                                               
Out[19]: array([5, 6, 7])

In [20]: arr[5:8] = 12                                                                                          

In [21]: arr                                                                                                    
Out[21]: array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])

数组的切片是在原数组的视图 任何对于视图的修改都会反映在原数组上



In [16]: arr = np.arange(10)                                                                                    

In [17]: arr                                                                                                    
Out[17]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [18]: arr[5]                                                                                                 
Out[18]: 5

In [19]: arr[5:8]                                                                                               
Out[19]: array([5, 6, 7])

In [20]: arr[5:8] = 12                                                                                          

In [21]: arr                                                                                                    
Out[21]: array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])

In [22]: arr_slice = arr[5:8]                                                                                   

In [23]: arr_slice                                                                                              
Out[23]: array([12, 12, 12])

In [24]: arr_slice[1] = 12345                                                                                   

In [25]: arr                                                                                                    
Out[25]: 
array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,
           9])
In [26]: arr_slice[:] = 11                                                                                      

In [27]: arr_slice[:] = 11                                                                                      

In [28]: arr_slice                                                                                              
Out[28]: array([11, 11, 11])

In [29]: arr                                                                                                    
Out[29]: array([ 0,  1,  2,  3,  4, 11, 11, 11,  8,  9])
当我使用arr_slice改变 也会使原数组改变

如果想要一分数组切片的拷贝不是一分视图就必须显式复制这个数组
arr[5:8].copy()

数组具有多维性质 性质和c语言中的多维数组引用方式相同

多维数组的切片也都是数组的视图并非是副本
In [31]: arr[1:6]                                                                                               
Out[31]: array([ 1,  2,  3,  4, 11])

In [32]: arr3d = np.array([[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]])                                               

In [33]: arr3d                                                                                                  
Out[33]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6],
        [ 7,  8,  9],
        [10, 11, 12]]])

In [34]: arr3d[0]                                                                                               
Out[34]: 
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])

In [35]: arr3d = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])                                             

In [36]: arr3d                                                                                                  
Out[36]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

In [37]: arr3d[0]                                                                                               
Out[37]: 
array([[1, 2, 3],
       [4, 5, 6]])

In [38]: old_value = arr3d[0].copy()                                                                            

In [39]: arr3d                                                                                                  
Out[39]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

In [40]: arr3d[0] = old_value                                                                                   

In [41]: arr3d                                                                                                  
Out[41]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

In [42]: arr3d[1][0]                                                                                            
Out[42]: array([7, 8, 9])

In [43]: x = arr3d[1]                                                                                           

In [44]: x                                                                                                      
Out[44]: 
array([[ 7,  8,  9],
       [10, 11, 12]])

In [45]: x[0]                                                                                                   
Out[45]: array([7, 8, 9])





数组的切片索引
In [51]: arr3d                                                                                                  
Out[51]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

In [52]: arr3d[:2]                                                                                              
Out[52]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

In [53]: arr3d[:1]                                                                                              
Out[53]: 
array([[[1, 2, 3],
        [4, 5, 6]]])




In [59]: arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])                                                            

In [60]: arr2d                                                                                                  
Out[60]: 
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

In [61]: arr2d[:2,1:]                                                                                           
Out[61]: 
array([[2, 3],
       [5, 6]])

In [62]: arr2d[1,2:]                                                                                            
Out[62]: array([6])

In [63]: arr2d[1,:2]                                                                                            
Out[63]: array([4, 5])

In [64]: arr2d[:2,2]                                                                                            
Out[64]: array([3, 6])

In [65]: arr2d[:,:1]                                                                                            
Out[65]: 
array([[1],
       [4],
       [7]])




In [66]: arr2d[:2,1:] = 0                                                                                       

In [67]: arr2d                                                                                                  
Out[67]: 
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])
对切片表达式赋值将会将整个切片重新赋值


布尔索引

In [68]: names = np.array(['Bob','Joe','Will','Bob','Will','Joe','Joe'])                                        
#随机生成随机正态分布的数据
In [69]: data = np.random.randn(7,4)                                                                            

In [70]: names                                                                                                  
Out[70]: array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')

In [71]: data                                                                                                   
Out[71]: 
array([[ 2.94001766,  0.09248174,  0.68509582,  1.27685651],
       [ 0.04748004, -1.34993441, -0.3132116 , -0.57436384],
       [-0.47421988,  2.02328275, -1.11782509,  0.57036834],
       [ 0.14907217,  0.60973313, -1.46153436, -0.89193112],
       [-0.31217308, -0.61779889,  0.77001826,  0.93570081],
       [ 0.895763  , -0.45234065, -0.6081129 ,  0.00942851],
       [ 0.09768849, -1.8116358 , -0.52224371, -0.17076268]])
#假设每个人名都与data数组中的一行对应 数组的比较操作可以项量化 names数组和字符串‘BOb’会产生一个bool数组
In [72]: names == 'Bob'                                                                                         
Out[72]: array([ True, False, False,  True, False, False, False])
#使用传入参数将data数组切片
In [73]: data[names == 'Bob']                                                                                   
Out[73]: 
array([[ 2.94001766,  0.09248174,  0.68509582,  1.27685651],
       [ 0.14907217,  0.60973313, -1.46153436, -0.89193112]])

当bool数组的长度不正确时，bool值选择数据的方法不会i报错 使用这个特性时要小心

#在使用筛选时候 同时可以使用索引
#另外可以使用逻辑运算符进行条件运算 将数据进一步取值 如：！（非） ～（取反）
In [74]: data[names == 'Bob',2:]                                                                                
Out[74]: 
array([[ 0.68509582,  1.27685651],
       [-1.46153436, -0.89193112]])

In [75]: data[names == 'Bob',3]                                                                                 
Out[75]: array([ 1.27685651, -0.89193112])

python中的关键字 and or 对bool值数组无效 必须使用逻辑运算符进行运算


神奇索引
用于描述整数数组进行数据索引

#选出一个特定顺序子集 负的从尾部进行索引
array([[0., 0., 0., 0.],
       [1., 1., 1., 1.],
       [2., 2., 2., 2.],
       [3., 3., 3., 3.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [6., 6., 6., 6.],
       [7., 7., 7., 7.]])

In [84]: arr[[4,3,0,6]]                                                                                         
Out[84]: 
array([[4., 4., 4., 4.],
       [3., 3., 3., 3.],
       [0., 0., 0., 0.],
       [6., 6., 6., 6.]])

In [85]: arr[[-3,-5,-7]]                                                                                        
Out[85]: 
array([[5., 5., 5., 5.],
       [3., 3., 3., 3.],
       [1., 1., 1., 1.]])


In [86]: arr = np.arange(32).reshape((8,4))                                                                     

In [87]: arr                                                                                                    
Out[87]: 
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
#前面为选中行 后面为选中列
In [88]: arr[[1,5,7,2],[0,3,1,2]]                                                                               
Out[88]: array([ 4, 23, 29, 10])
#另一种实现方法 
In [92]: arr[[1,5,7,2]][:,[0,3,1,2]]                                                                            
Out[92]: 
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])


数组的转置与换轴
转置是一种特殊的数据重组形式 可以返回底层数据的视图不需要复制任何内容

In [94]: arr = np.arange(15).reshape((3,5))                                                                     

In [95]: arr                                                                                                    
Out[95]: 
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])


In [96]: arr.T                                                                                                  
Out[96]: 
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])

In [97]: arr = np.random.randn(6,3)                                                                             

In [98]: arr                                                                                                    
Out[98]: 
array([[-0.74042497, -0.4147445 ,  0.64340812],
       [-2.42811765,  0.15337417, -0.6814799 ],
       [ 0.85025887, -0.12945606, -2.08955361],
       [ 1.26985434,  0.79330715, -0.18826565],
       [ 0.41972906, -0.3086791 , -2.49119017],
       [ 0.46622032, -0.54361929,  0.05380778]])
#使用dot方法计算两个矩阵内积
In [99]: np.dot(arr.T,arr)                                                                                      
Out[99]: 
array([[ 9.17298852,  0.44898206, -1.85795216],
       [ 0.44898206,  1.23243647,  0.48950889],
       [-1.85795216,  0.48950889, 11.48899086]])



In [100]: arr = np.arange(16).reshape((2,2,4))                                                                  

In [101]: arr                                                                                                   
Out[101]: 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
#轴重新排序 将原本第二轴变为第一轴 原本第一轴变为第二个 最后一个轴没有改变
In [103]: arr.transpose((1,0,2))                                                                                
Out[103]: 
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])



#该方法接受一对轴编号作为参数 并对轴进行调整用于重组数组
In [11]: arr                                                                                                                            
Out[11]: 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

In [12]: arr.swapaxes(1,2)                                                                                                              
Out[12]: 
array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],

       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])



通用函数
可以称为ufunc 是一种在ndarray数据中进行逐个元素操作的函数，某些简单函数接受一个或者多个标量树值 并产生一个或者多个标量结果 


In [13]: arr = np.arange(10)                                                                                                            

In [14]: arr                                                                                                                            
Out[14]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [15]: np.sqrt(arr)                                                                                                                   
Out[15]: 
array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])

In [16]: x = np.random.randn(8)                                                                                                         

In [17]: y = np.random.randn(8)                                                                                                         

In [18]: x                                                                                                                              
Out[18]: 
array([-1.50777256, -0.3754989 ,  1.93874212,  1.76545153,  0.86426839,
        0.21813696, -0.27403047,  1.01192174])

In [19]: y                                                                                                                              
Out[19]: 
array([ 0.19530466, -1.44764202,  0.14942003,  0.05646695, -0.68756559,
        0.00159567, -0.71615443,  0.53444958])

In [20]: np.maximum(x,y)                                                                                                                
Out[20]: 
array([ 0.19530466, -0.3754989 ,  1.93874212,  1.76545153,  0.86426839,
        0.21813696, -0.27403047,  1.01192174])

#modf 是python内建函数的divmod的向量版返回一个浮点数组的小数部分与整数部分
In [21]: arr = np.random.randn(7)*5                                                                                                     

In [22]: arr                                                                                                                            
Out[22]: 
array([-6.6923553 ,  4.33673541, -1.90903555,  2.80579466,  6.26743353,
        6.67003509,  1.40378026])

In [23]: remainder,whole_part = np.modf(arr)                                                                                            

In [24]: remainder                                                                                                                      
Out[24]: 
array([-0.6923553 ,  0.33673541, -0.90903555,  0.80579466,  0.26743353,
        0.67003509,  0.40378026])

In [25]: whole_part                                                                                                                     
Out[25]: array([-6.,  4., -1.,  2.,  6.,  6.,  1.])





使用数组进行面向数组编程
使用numpy数组可以利用简单数组表达式完成多种数据操作任务 不用写大量循环
用数组表达式替代显式循环的方法称为 向量化

In [29]: points = np.arange(-5,5,0.01)                                                                                                  

In [30]: xs,ys = np.meshgrid(points,points)                                                                                             

In [31]: ys                                                                                                                             
Out[31]: 
array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ...,
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])

In [32]: xs                                                                                                                             
Out[32]: 
array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       ...,
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])

In [33]: z = np.sqrt(xs**2 + ys**2)                                                                                                     

In [34]: z                                                                                                                              
Out[34]: 
array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
        7.06400028],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       ...,
       [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
        7.04279774],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568]])

In [35]: import matplotlib.pyplot as plt                                                                                                

In [36]: plt.imshow(z,cmap=plt.cm.gray); plt.colorbar()                                                                                 
Out[36]: <matplotlib.colorbar.Colorbar at 0x7fab8d005550>

In [37]: plt.title("Image plot of $\sqrt{x^2+y^2}$ for a grid of values")                                                               
Out[37]: Text(0.5, 1.0, 'Image plot of $\\sqrt{x^2+y^2}$ for a grid of values')

In [38]: plt.show()                                              

numpy.where 函数是三元表达式x if condition else y 的向量版本

#numpy.where 类似于c语言中的选择语句三元运算符
In [39]: xarr = np.array([1.1,1.2,1.3,1.4,1.5])                                                                                         

In [40]: yarr = np.array([2.1,2.2,2.3,2.4,2.5])                                                                                         

In [41]: cond = np.array([True,False,True,True,False])                                                                                  

In [42]: result = [(x if c else y) for x,y,c in zip(xarr,yarr,cond)]                                                                    

In [43]: result                                                                                                                         
Out[43]: [1.1, 2.2, 1.3, 1.4, 2.5]

In [44]: result = np.where(cond,xarr,yarr)                                                                                              

In [45]: result                                                                                                                         
Out[45]: array([1.1, 2.2, 1.3, 1.4, 2.5])

In [46]: arr = np.random.randn(4,4)                                                                                                     

In [47]: arr                                                                                                                            
Out[47]: 
array([[-0.36181383, -0.49302575, -0.51230141, -0.69378717],
       [ 1.41422519, -0.19646418, -0.47825598,  0.572948  ],
       [-1.89281909,  0.13237797, -1.84185684,  0.2493919 ],
       [-0.62824577, -0.67507105, -0.28756863, -1.21170562]])

In [48]: arr > 0                                                                                                                        
Out[48]: 
array([[False, False, False, False],
       [ True, False, False,  True],
       [False,  True, False,  True],
       [False, False, False, False]])

In [49]: np.where(arr>0,2,-2)                                                                                                           
Out[49]: 
array([[-2, -2, -2, -2],
       [ 2, -2, -2,  2],
       [-2,  2, -2,  2],
       [-2, -2, -2, -2]])

In [50]: np.where(arr>0,2,arr)                                                                                                          
Out[50]: 
array([[-0.36181383, -0.49302575, -0.51230141, -0.69378717],
       [ 2.        , -0.19646418, -0.47825598,  2.        ],
       [-1.89281909,  2.        , -1.84185684,  2.        ],
       [-0.62824577, -0.67507105, -0.28756863, -1.21170562]])

数学和统计方法
许多关于计算整个数组统计值或关于轴向数据的数学函数 可以作为数组类型的方法被调用，可以使用聚合函数（缩减函数） 
In [51]: arr = np.random.randn(5,4)                                                                                                     

In [52]: arr                                                                                                                            
Out[52]: 
array([[-1.50727842, -0.86837485,  1.08891696,  1.05384757],
       [ 1.45218707, -0.37771369,  0.45317828, -1.24013015],
       [-0.8838425 , -1.03832486,  1.37756751, -1.03788359],
       [ 0.55528528, -0.7615696 ,  1.08463348, -1.27174852],
       [-1.27934709, -1.39702881, -3.30586099, -1.23168823]])

In [53]: arr.mean()                                                                                                                     
Out[53]: -0.4567587567663053

In [54]: np.mean(arr)                                                                                                                   
Out[54]: -0.4567587567663053

In [55]: arr.sum                                                                                                                        
Out[55]: <function ndarray.sum>

In [56]: arr.sum()                                                                                                                      
Out[56]: -9.135175135326106

In [57]: arr.mean(axis=1)                                                                                                               
Out[57]: array([-0.05822218,  0.07188038, -0.39562086, -0.09834984, -1.80348128])

In [58]: arr.sum(axis=1)                                                                                                                
Out[58]: array([-0.23288873,  0.28752151, -1.58248344, -0.39339936, -7.21392512])

In [59]: arr.sum(axis = 0)                                                                                                              
Out[59]: array([-1.66299564, -4.4430118 ,  0.69843524, -3.72760292])

In [60]: arr = np.arange(0,7,1)                                                                                                         

In [61]: arr                                                                                                                            
Out[61]: array([0, 1, 2, 3, 4, 5, 6])

In [62]: arr = np.arange(0,8,1)                                                                                                         

In [63]: arr                                                                                                                            
Out[63]: array([0, 1, 2, 3, 4, 5, 6, 7])

In [64]: arr.cumsum()                                                                                                                   
Out[64]: array([ 0,  1,  3,  6, 10, 15, 21, 28])

In [65]: arr = np.array([[0,1,2],[3,4,5],[6,7,8]])                                                                                      

In [66]: arr                                                                                                                            
Out[66]: 
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

In [67]: arr.cumsum(axis=0)                                                                                                             
Out[67]: 
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])

In [68]: arr.cumprod(axis=1)                                                                                                            
Out[68]: 
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]])



axis = 1 列
axis = 0 行


布尔值数组的方法
In [5]: bools = np.array([False,False,True,False])                                                              

In [6]: bools.any()                                                                                             
Out[6]: True

In [7]: bools.all()                                                                                             
Out[7]: False

#对于bool值数组 any 检查数组中是否至少有一个True , all 检查是否每个值都是True


排序 
numpy数组可以使用sort方法按位置进行排序


In [8]: arr = np.random.randn(6)                                                                                

In [9]: arr                                                                                                     
Out[9]: 
array([ 0.67944287, -0.47540692,  1.78403566, -0.58655621, -0.6346273 ,
        0.18517217])

In [10]: arr.sort()                                                                                             

In [11]: arr                                                                                                    
Out[11]: 
array([-0.6346273 , -0.58655621, -0.47540692,  0.18517217,  0.67944287,
        1.78403566])

In [12]: arr = np.random.randn(5,3)                                                                             

In [13]: arr                                                                                                    
Out[13]: 
array([[-0.37386791, -0.86312593,  0.36908911],
       [-0.02272889, -0.74287507, -0.43980578],
       [ 0.63543663, -0.61295033, -0.09056214],
       [ 0.47091438,  1.30140019,  1.04466813],
       [ 1.68060622, -0.16003909, -0.73654842]])

In [14]: arr.sort(axis=1)                                                                                       

In [15]: arr                                                                                                    
Out[15]: 
array([[-0.86312593, -0.37386791,  0.36908911],
       [-0.74287507, -0.43980578, -0.02272889],
       [-0.61295033, -0.09056214,  0.63543663],
       [ 0.47091438,  1.04466813,  1.30140019],
       [-0.73654842, -0.16003909,  1.68060622]])

In [16]: arr.sort(axis=0)                                                                                       

In [17]: arr                                                                                                    
Out[17]: 
array([[-0.86312593, -0.43980578, -0.02272889],
       [-0.74287507, -0.37386791,  0.36908911],
       [-0.73654842, -0.16003909,  0.63543663],
       [-0.61295033, -0.09056214,  1.30140019],
       [ 0.47091438,  1.04466813,  1.68060622]])

np.sort 方法返回的是已经排序好的数组拷贝 不是对原数组按照位置排序

唯一值与其他集合逻辑

数组的集合操作
unique(x)              计算x的唯一值 并排序
intersect1d(x,y)       计算x与y的交集 并排序
union1d（x,y）          计算x和y的并集 并排序
in1d(x,y)               计算x中的元素是否包含在y中 返回一个布尔值数组
setdiff1d(x,y)          差集在x中不在y中的元素 
setxor1d(x,y)           异或集，在x或y中但是不属于xy交集的元素



使用数组进行文件输入和输出
numpy可以在硬盘中将数据以文本或者二进制文件的形式存入硬盘或者用硬盘载入

np.save np.load 高效存取硬盘数据的两大工具函数
以未压缩格式进行存储 后缀名.npy

 In [26]: arr = np.arange(10)                                                                                    

In [27]: np.save('some_array',arr) 


#如果文件存放路径没有写.npy后缀会被自动加入 

#savez在未压缩文件中加入多个数组对象
#当使用np.load 进行解压后使用类似字典结构进行调用

In [26]: arr = np.arange(10)                                                                                    

In [27]: np.save('some_array',arr)                                                                              

In [28]: np.savez('array_archive.npz',a = arr,b = arr)                                                          

In [29]: arch = np.load('array_archive.npz')                                                                    

In [30]: arch['b']                                                                                              
Out[30]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [31]: arch['a']                                                                                              
Out[31]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




线性代数
#dot 内积运算 np.dot(x,y) 等价于 x.dot(y)
In [32]: x = np.array([[1.,2.,3.],[4.,5.,6.]])                                                                  

In [33]: y = np.array([[6.,23.],[-1,7],[8,9]])                                                                  

In [34]: x                                                                                                      
Out[34]: 
array([[1., 2., 3.],
       [4., 5., 6.]])

In [35]: y                                                                                                      
Out[35]: 
array([[ 6., 23.],
       [-1.,  7.],
       [ 8.,  9.]])

In [36]: x.dot(y)                                                                                               
Out[36]: 
array([[ 28.,  64.],
       [ 67., 181.]])

In [37]: np.dot(x,y)                                                                                            
Out[37]: 
array([[ 28.,  64.],
       [ 67., 181.]])

一个二维数组与一个长度合适的一维数组之间的矩阵乘积 结果是一个一维数组
In [38]: np.ones(3)                                                                                             
Out[38]: array([1., 1., 1.])

In [39]: np.dot(x,np.ones(3))                                                                                   
Out[39]: array([ 6., 15.])
#@运算符等价于点乘矩阵
In [40]: x @ np.ones(3)                                                                                         
Out[40]: array([ 6., 15.])

numpy中存在linalg拥有一个矩阵分解的标准函数集 以及其他常用函数 例如 求逆矩阵 行列式求解

常用numpy.linalg函数
diag           将一个方阵的对角元素作为一维数组返回/将一个一维数组转换成一个稀疏矩阵 对角线上是一维数组的元素
dot            矩阵点乘
trace          计算矩阵迹
det            计算矩阵行列式
eig            计算方阵的特征值和特征向量
inv            计算方阵的逆矩阵
pinv           计算矩阵的Moore-Penrose伪逆
qr             计算QR分解
svd            计算奇异值分解(SVD)
solve          求解AX=B 其中A是方阵
lstsq          计算AX=B 的最小二乘解



伪随机数生成
numpy.random 填补了python内建的random 模块不足 

np.random.normal()正态分布
高斯分布的概率密度函数

              

numpy中

numpy.random.normal(loc=0.0, scale=1.0, size=None)  

参数的意义为：

　　loc:float

　　概率分布的均值，对应着整个分布的中心center

　　scale:float

　　概率分布的标准差，对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高

　　size:int or tuple of ints

　　输出的shape，默认为None，只输出一个值

　　我们更经常会用到np.random.randn(size)所谓标准正太分布（μ=0, σ=1），对应于np.random.normal(loc=0, scale=1, size)


伪随机数是有具有确定性型为的算法根据随机数生成器中的随机数种子生成
#更改随机数生成的种子
np.random.seed(1234)
numpy.random 中的数据生成函数使用了一个全局随机数种子 为了避免全局状态 可以使用numpy.random.RandomState创建一个随机数生成器
使得数据独立于其他随机数状态

numpy.random中部分函数列表
seed            向随机数生成器传递随机状态种子
permutation     返回一个序列的随机排列 或者返回一个乱序的整数范围序列
shuffle         随机排列一个序列
rand            从均匀分布中抽取样本
randint         根据给定的有低到高的范围抽取随机整数
randn           从均值0方差1 的正态分布中抽取样本
binomial        从二项分布中抽取样本
normal          从正态（高斯）分布中抽取样本
beta            从beta分布中抽取样本
chisquare       从卡方分布中抽取样本
gamma           从gama分布中抽取样本
uniform         从均匀[0,1)分布中抽取样本

随机漫步



pandas入门

pandas主要处理表格型数据或者异质型数据 numpy适合处理同质型树值类数组数据


pandas两个常用工具数据结构：series DataFrame 
Series 是一种一维数组型对象 包含了一个值序列，并且包含了数据标签（索引index）

In [59]: import pandas as pd                                                                                    

In [60]: obj = pd.Series([4,7,-5,3])                                                                            

In [61]: obj                                                                                                    
Out[61]: 
0    4
1    7
2   -5
3    3
dtype: int64

In [62]: obj.values                                                                                             
Out[62]: array([ 4,  7, -5,  3])

In [63]: obj.index                                                                                              
Out[63]: RangeIndex(start=0, stop=4, step=1)

In [64]: obj2 = pd.Series([4,7,-5,3],index = ['d','b','a','c'])                                                 

In [65]: obj2                                                                                                   
Out[65]: 
d    4
b    7
a   -5
c    3
dtype: int64

In [66]: obj2['a']                                                                                              
Out[66]: -5

In [67]: obj2['d'] = 6                                                                                          

In [68]: obj2[['c','a','d']]                                                                                    
Out[68]: 
c    3
a   -5
d    6
dtype: int64


In [69]: obj2[obj2>0]                                                                                           
Out[69]: 
d    6
b    7
c    3
dtype: int64

In [70]: obj2*2                                                                                                 
Out[70]: 
d    12
b    14
a   -10
c     6
dtype: int64

In [71]: obj                                                                                                    
Out[71]: 
0    4
1    7
2   -5
3    3
dtype: int64

In [72]: obj2                                                                                                   
Out[72]: 
d    6
b    7
a   -5
c    3
dtype: int64

In [73]: np.exp(obj2)                                                                                           
Out[73]: 
d     403.428793
b    1096.633158
a       0.006738
c      20.085537
dtype: float64

In [74]: 'b' in obj2                                                                                            
Out[74]: True

In [75]: 'e' in obj2                                                                                            
Out[75]: False

In [76]: sdata = {'Ohio':35000,'Texas':71000,'Oregon':16000,'Utah':5000}                                        

In [77]: obj3 = pd.Series(sdata)                                                                                

In [78]: obj3                                                                                                   
Out[78]: 
Ohio      35000
Texas     71000
Oregon    16000
Utah       5000
dtype: int64

In [79]: states = {'California','Ohio','Oregon','Texas'}                                                        

In [80]: obj4 = pd.Series(sdata,index = states)                                                                 

In [81]: obj4                                                                                                   
Out[81]: 
Texas         71000.0
California        NaN
Oregon        16000.0
Ohio          35000.0
dtype: float64

In [82]: pd.isnull(obj4)                                                                                        
Out[82]: 
Texas         False
California     True
Oregon        False
Ohio          False
dtype: bool

In [83]: pd.notnull(obj4)                                                                                       
Out[83]: 
Texas          True
California    False
Oregon         True
Ohio           True
dtype: bool

In [84]: obj4.isnull() 
    ...:  
    ...:                                                                                                        
Out[84]: 
Texas         False
California     True
Oregon        False
Ohio          False
dtype: bool

In [85]: obj3                                                                                                   
Out[85]: 
Ohio      35000
Texas     71000
Oregon    16000
Utah       5000
dtype: int64

In [86]: obj4                                                                                                   
Out[86]: 
Texas         71000.0
California        NaN
Oregon        16000.0
Ohio          35000.0
dtype: float64

In [87]: obj3 + obj4                                                                                            
Out[87]: 
California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64

In [88]: obj4.name = 'population'                                                                               

In [89]: obj4.index.name = 'state'                                                                              

In [90]: obj4                                                                                                   
Out[90]: 
state
Texas         71000.0
California        NaN
Oregon        16000.0
Ohio          35000.0
Name: population, dtype: float64

In [91]: obj                                                                                                    
Out[91]: 
0    4
1    7
2   -5
3    3
dtype: int64

In [92]: obj.index = ['Bob','Steve','Jeff','Ryan']                                                              

In [93]: obj                                                                                                    
Out[93]: 
Bob      4
Steve    7
Jeff    -5
Ryan     3
dtype: int64


DataFrame 
DataFrame 表示的是矩阵的数据表  包含已经排序的列集合 每一列可以是不同的值类型（数值，字符串，bool值）
DataFrame中的数据是以一个或者多个二维块存放的 

In [96]: data = {'state':['Ohio','Ohio','Ohio','Nevada','Nevada','Nev
    ...: ada'],'year':[2000,2001,2002,2001,2002,2003],'pop':[1.5,1.7,
    ...: 3.6,2.4,2.9,3.2]}                                           

In [97]: frame = pd.DataFrame(data)                                  

In [98]: frame                                                       
Out[98]: 
    state  year  pop
0    Ohio  2000  1.5
1    Ohio  2001  1.7
2    Ohio  2002  3.6
3  Nevada  2001  2.4
4  Nevada  2002  2.9
5  Nevada  2003  3.2

head()方法选取前五行
In [99]: frame.head()                                                
Out[99]: 
    state  year  pop
0    Ohio  2000  1.5
1    Ohio  2001  1.7
2    Ohio  2002  3.6
3  Nevada  2001  2.4
4  Nevada  2002  2.9

In [100]: frame.head(2)                                              
Out[100]: 
  state  year  pop
0  Ohio  2000  1.5
1  Ohio  2001  1.7

如果指定列序列 DataFrame的列按照指定顺序进行排列
In [101]: pd.DataFrame(data,columns=['year','state','pop'])          
Out[101]: 
   year   state  pop
0  2000    Ohio  1.5
1  2001    Ohio  1.7
2  2002    Ohio  3.6
3  2001  Nevada  2.4
4  2002  Nevada  2.9
5  2003  Nevada  3.2


In [102]: pd.DataFrame(data,columns=['year','state','pop','debt'],ind
     ...: ex=['one','two','three','four','five','six'])              
Out[102]: 
       year   state  pop debt
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN
six    2003  Nevada  3.2  NaN
如果传入的列在data中找不到对应的就会使用NAN代替

frame2[column]适用于任何列的名，但是frame2.column只有在列名是一个合理的Python变量名时才适用。

In [109]: frame2['year']                                             
Out[109]: 
one      2000
two      2001
three    2002
four     2001
five     2002
six      2003
Name: year, dtype: int64

In [110]: frame2.year                                                
Out[110]: 
one      2000
two      2001
three    2002
four     2001
five     2002
six      2003
Name: year, dtype: int64

In [111]: frame2                                                     
Out[111]: 
       year   state  pop debt
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN
six    2003  Nevada  3.2  NaN

In [112]: frame2['state']                                            
Out[112]: 
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object

In [113]: frame2.state                                               
Out[113]: 
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object

#将列表或者数组赋值给某个列时 长度必须和DataFrame 长度相匹配 如果赋值的是一个series 会精确匹配DataFrame的索引
所有的空位都会被填上缺失值NAN
In [58]: val = pd.Series([-1.2, -1.5, -1.7], index=['two', 'four', 'five'])
In [59]: frame2['debt'] = val
In [60]: frame2
Out[60]: 
       year   state  pop  debt
one    2000    Ohio  1.5   NaN
two    2001    Ohio  1.7  -1.2
three  2002    Ohio  3.6   NaN
four   2001  Nevada  2.4  -1.5
five   2002  Nevada  2.9  -1.7
six    2003  Nevada  3.2   NaN

为不存在的列赋值会创建一个新列 del用于删除列

In [134]: frame2['eastern'] = (frame2.state == 'Ohio')               

In [135]: frame2                                                     
Out[135]: 
   year   state  pop  debt  eastern
1  2000    Ohio  1.5   NaN     True
2  2001    Ohio  1.7  -1.2     True
3  2002    Ohio  3.6   NaN     True
4  2001  Nevada  2.4  -1.5    False
5  2002  Nevada  2.9  -1.7    False
6  2003  Nevada  3.2   NaN    False
#必须使用frame2['eastern'] 创建新的列 不能使用frame2.eastern创建新的列

#使用del语句删除frame2中eastern列
In [136]: del frame2['eastern']                                      

In [137]: frame2                                                     
Out[137]: 
   year   state  pop  debt
1  2000    Ohio  1.5   NaN
2  2001    Ohio  1.7  -1.2
3  2002    Ohio  3.6   NaN
4  2001  Nevada  2.4  -1.5
5  2002  Nevada  2.9  -1.7
6  2003  Nevada  3.2   NaN
In [138]: frame2.columns                                             
Out[138]: Index(['year', 'state', 'pop', 'debt'], dtype='object')


通过索引方式返回的列只是相应数据的视图 不是副本 所有的修改将会放映到原DataFrame上 通过Series 的copy方法即可指定复制列

嵌套字典传给DataFrame pandas解释为外层字典的键为列 内层键作为行索引
In [139]: pop = {'Nevada':{2001:2.4,2002:2.9},'Ohio':{2000:1.5,2001:1
     ...: .7,2002:3.6}}                                              

In [140]: frame3 = pd.DataFrame(pop)                                 

In [141]: frame3                                                     
Out[141]: 
      Nevada  Ohio
2001     2.4   1.7
2002     2.9   3.6
2000     NaN   1.5

Nevada Ohio ------------外层键-----------列索引
2001 2000 2002 ---------内层键-----------行索引

In [142]: frame3.T                                                   
Out[142]: 
        2001  2002  2000
Nevada   2.4   2.9   NaN
Ohio     1.7   3.6   1.5

#分割framedata
In [144]: frame3                                                     
Out[144]: 
      Nevada  Ohio
2001     2.4   1.7
2002     2.9   3.6
2000     NaN   1.5

In [145]: pdata ={'Ohio':frame3['Ohio'][:-1],'Nevada':frame3['Nevada'
     ...: ][:2]}                                                     

In [146]: pd.DataFrame(pdata)                                        
Out[146]: 
      Ohio  Nevada
2001   1.7     2.4
2002   3.6     2.9
#可以设定列名与行索引名 
In [147]: frame3.index.name= 'years';frame3.columns.name = 'states'  

In [148]: frame3                                                     
Out[148]: 
states  Nevada  Ohio
years               
2001       2.4   1.7
2002       2.9   3.6
2000       NaN   1.5
#将除了行与列索引的名字除去之后的所有表内值显示出来
In [149]: frame3.values                                              
Out[149]: 
array([[2.4, 1.7],
       [2.9, 3.6],
       [nan, 1.5]])

In [150]: frame2.values                                              
Out[150]: 
array([[2000, 'Ohio', 1.5, nan],
       [2001, 'Ohio', 1.7, -1.2],
       [2002, 'Ohio', 3.6, nan],
       [2001, 'Nevada', 2.4, -1.5],
       [2002, 'Nevada', 2.9, -1.7],
       [2003, 'Nevada', 3.2, nan]], dtype=object)

索引对象

In [151]: obj = pd.Series(range(3),index=['a','b','c'])              

In [152]: obj                                                        
Out[152]: 
a    0
b    1
c    2
dtype: int64

In [153]: index = obj.index                                          

In [154]: index                                                      
Out[154]: Index(['a', 'b', 'c'], dtype='object')

In [155]: index[1:]                                                  
Out[155]: Index(['b', 'c'], dtype='object')
#index对象不可被修改 不可变常量
#不可变可以使得index对象在多个数据结构之间安全共享
In [161]: obj2.index == labels                                       
Out[161]: array([ True,  True,  True])

In [162]: obj2.index is labels                                       
Out[162]: True

In [163]: obj2.index                                                 
Out[163]: Int64Index([0, 1, 2], dtype='int64')



#pandas 的 index 可以包含重复的标签
In [168]: dup_labels = pd.Index(['foo','foo','bar','bar'])           

In [169]: dup_labels                                                 
Out[169]: Index(['foo', 'foo', 'bar', 'bar'], dtype='object')
选择重复的标签 会显示所有的结果

append------------------------连接另一个index对象 产生一个新的index
differebce--------------------计算差集 得到一个index
intersecton-------------------计算交集
union-------------------------计算并集
isin--------------------------计算一个指示各值是否包含在参数集合中的bool数组
delete------------------------删除索引i处，并且得到一个新的index
drop--------------------------删除传入的值 得到一个新的index
insert------------------------将元素插入到索引i处 并得到一个新的index
is_monotonic------------------将各元素均大于等于前一个元素时，返回TRUE
is_unique---------------------当index没有重复值时，返回TRUE
unique------------------------计算index中唯一值的数组














































